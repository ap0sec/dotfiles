#+TITLE: 画像処理プログラミング
#+AUTHOR: 小高 拓海
#+DATE: 再提出期限：2018年12月6日
#+LATEX_HEADER: \usepackage{preamble}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{bm}
#+LATEX_CLASS: jsarticle
#+OPTIONS: toc:nil timestamp:nil

* 目的
画像処理分野において，画像の特徴を知る手段の一つとして，周波数空間へ写像をとることが挙げられる．その手法の一つである2次元Hadamard（アマダール）変換について実装すると共に理解を深める．

* 原理
** Hadamard行列
Hamadard行列とは，のちに2次元Hadamard変換を行うために必要となる行列であり，1と-1を要素に持つ対称行列である．また，各列ベクトル（行ベクトル）同士は互いに直交している．Hadamard行列の大きさは行・列共に任意であるが，求めやすさから，$2^m$ 次（$m$ は正整数）の正方行列を用いることが多い．

行列を算出する手法は2種類あるため，それぞれについて手順を示す．

*** 再帰法
再帰法とは名前の通り，目的の次数に到達するまで，初期行列を再帰的に組み合わせていく手法である．

初期行列$\bm{H}_2$ （2次のHadamard行列）を式([[eq:q1]])に示す．

#+NAME: eq:q1
\begin{equation}
\bm{H}_2 = \left[
                        \begin{array}{rr}
                          1 & 1 \\
                          1 & -1 
                        \end{array}
                   \right]
\end{equation}

式([[eq:q1]])を再帰的に用いて$\bm{H}_4$ を求めたとき，式([[eq:q2]])のようになる．

#+NAME: eq:q2
\begin{equation}
\bm{H}_4 = \left[
                        \begin{array}{rr}
                          \bm{H}_2 & \bm{H}_2 \\
                          \bm{H}_2 & -\bm{H}_2
                        \end{array}
                   \right]
                 = \left[
                        \begin{array}{rrrr}
                          1 & 1 & 1 & 1 \\
                          1 & -1 & 1 & -1 \\
                          1 & 1 & -1 & -1 \\
                          1 & -1 & -1 & 1
                        \end{array}
                   \right]
\end{equation}

これらを一般化すると，$2k$ 次のHadamard行列$\bm{H}_{2k}$ は式([[eq:q3]])のように表せる．

#+NAME: eq:q3
\begin{equation}
\bm{H}_{2k} = \left[
                        \begin{array}{rr}
                          \bm{H}_k & \bm{H}_k \\
                          \bm{H}_k & -\bm{H}_k
                        \end{array}
                   \right]
\end{equation}

*** 直接法
Hadamard行列の各要素は，直接的に求めることもできる．

N次のHadamard行列$\bm{H}_N$ の$i$ 行 $j$ 列の要素を$\bm{H}_N(j,i)$ と表すことにする（$i$ ，$j$ ともに$0,1,…,N-1$）．このとき，Hadamard行列$\bm{H}_N$ の行と列の数がともに$N=2^m$ であることに注意して，$j$ と$i$ を各々$m$ 桁の2進数によって式([[eq:q4]])，([[eq:q5]])のように表す．

#+NAME: eq:q4
\begin{equation}
j = j_{m-1} \;\; j_{m-2} \;\; … \;\; j_1 \;\; j_0
\end{equation}

#+NAME: eq:q5
\begin{equation}
i = i_{m-1} \;\; i_{m-2} \;\; … \;\; i_1 \;\; i_0
\end{equation}
なお，2進数が$m$ 桁よりも小さい桁数になる場合は，それより上位の桁は全て0とする．

ここで，式([[eq:q6]])で表せる数$p$ を定義する．

#+NAME: eq:q6
\begin{equation}
p = \sum_{k=0}^{m-1} i_k j_k
\end{equation}
すなわち，$p$ は各bitのANDをとったときに1となる合計数である．たとえば，$i=2$($i_{(2)} = 10$)，$j=3$($j_{(2)}=11$)のとき，$p=1$ である．

この$p$ を用いると，Hadamard行列$\bm{H}_N$ の$i$ 行$j$ 列の要素$h_N(j,i)$ は式([[eq:q7]])のように表される．

#+NAME: eq:q7
\begin{equation}
h_N(j,i) = (-1)^{\{p \;mod \; 2\}}
\end{equation}
ここで$p \;mod \; 2$ は，2に対する$p$ の剰余を表す．

** シーケンシ
[[再帰法]]節，[[直接法]]節のいずれかで求めたHadamard行列の行を，「$1$ から$-1$ （または$-1$ から$1$）へ反転する回数」の順序に並べ替える．この反転回数をシーケンシ(sequency)という．求めたHadamard行列をシーケンシの順に並べるには，各行に対し，置換先の行番号を求める必要がある．

$N$ 次（$N=2^m$）のHadamard行列$\bm{H}_N$ の一つの行ベクトル$\bm{h}_i$ を式([[eq:q8]])のように表すことにする．

#+NAME: eq:q8
\begin{equation}
\bm{h}_i = (h_{0i} \;\; h_{1i} \;\; … \;\; h_{(N-1)i})
\end{equation}
このとき，$\bm{h}_i$ のシーケンシ$s(i)$ は式([[eq:q9]])のように定義される．

#+NAME: eq:q9
\begin{equation}
s(i) = \frac{1}{2} \sum_{j=0}^{N-2} \; | \; h_{ji} - h_{(j+1)i} \; |
\end{equation}
そして，$i$ 行目を$s(i)$ 行目に移動すればよい．

なお，ここでは行に対する操作を説明したが，Hadamard行列は対称行列であるため，同様の操作を列に対して適用しても同じ結果が得られる．

** 2次元Hadmard行列
シーケンシの順に並べ替えたHadamard行列$\bm{H}_N$ を用いて，画像$\bm{F}$ を周波数空間へ変換する．これを2次元Hadamard変換という．その手法は2種類あるため，それぞれ解説する．

*** 行列演算による変換
2次元Hadamard変換は，行列演算を用いると式([[eq:q10]])で定義される．ここで$t$ は行列の転置を表すが，Hadamard行列は対称行列であることに注意する．

#+NAME: eq:q10
\begin{equation}
\bm{G} = \frac{1}{N} \bm{H}_N \bm{F} \bm{H}^t_N
\end{equation}

求めた変換係数$\bm{G}$ から原画像$\bm{F}$ を求める逆変換は，式([[eq:q11]])で定義される．

#+NAME: eq:q11
\begin{equation}
\bm{F} = \frac{1}{N} {\bm{H}_N}^{-1} \bm{G} {\bm{H}^t_N}^{-1}
\end{equation}

Hadamard行列は，ユニタリー行列かつエルミート行列である．このとき，全ての要素が実数である場合は$\bm{H}_N = {\bm{H}_N}^{-1}$ が成立する．Hadamard行列は要素に$1,-1$ のみを持つため条件を満たす．よって逆行列として元の$\bm{H}_N$ をそのまま用いることができる．

なお，式([[eq:q10]])，([[eq:q11]])を2次元Hadamard変換対という．

*** 2次元基底ベクトルとの内積による変換
    
Hadamard行列$\bm{H}_4$ の2次元基底ベクトル$\bm{U}_{wv}$ を図[[fig:kitei]]に示す．この図における白は$1$ を，黒は$-1$ を表す．

#+CAPTION: Hadamard行列$\bm{H}_4$ の2次元基底ベクトル$\bm{U}_{wv}$
#+NAME: fig:kitei
#+ATTR_LaTeX: :width 7cm
[[./img/31.png]]

$\bm{U}_{wv}$ と画像$\bm{F}$ との内積を式([[eq:q12]])により求めることで，変換係数$g_{wv}$ が求まる．

#+NAME: eq:q12
\begin{equation}
g_{wv} = \frac{1}{N^2} \bm{U}_{wv} \cdot \bm{F}
\end{equation}

このようにして求めた$g_{wv}$ を用いて，式([[eq:q13]])によって原画像$\bm{F}$ を求める．

#+NAME: eq:q13
\begin{equation}
\bm{F} = \sum_{v=0}^{N-1} \sum_{w=0}^{N-1} g_{wv} \bm{U}_{wv}
\end{equation}
すなわち，原画像$\bm{F}$ の各要素$f(x,y)$ を求めるには，式([[eq:q14]])の演算を行えばよい．ただし，$u_{wv}(x,y)$ は$\bm{U}_{wv}$ の$(x,y)$ 成分を示す．

#+NAME: eq:q14
\begin{equation}
f(x,y) = \sum_{v=0}^{N-1} \sum_{w=0}^{N-1} g_{wv} u_{wv}(x,y)
\end{equation}

式([[eq:q13]])は，$g_{wv}$ を荷重とする各基底ベクトルの線形和によって$\bm{F}$ が求められることを意味する．逆に式([[eq:q12]])は，原画像$\bm{F}$ 内に各基底ベクトルのパターンがどれだけ含まれているのかを求めるものといえる．
** Portable Gray Map
実験で用いる画像は，256×256画素のモノクロ256階調とする．画像データの格納形式にはさまざまなものがあるが，本実験ではPGM（Portable Gray Map）のバイナリデータ形式のファイルを用いる．PGM形式のファイルは，ヘッダ部分とデータ部分に大別できる．

ヘッダ部分には，以下の情報が記録されている．

\begin{tabbing}
12345678910123 \= 12345678 \= \kill
マジックナンバ \> 画像ファイルの形式を示す2[byte]のデータ． \\
画像サイズ \> 画像の横幅，縦幅． \\
最大輝度値 \> 画像の輝度（明るさ）として用いる値の最大値．最小値は0として暗黙的に定義されている．
\end{tabbing}

データ部分には，各画素の輝度値が画像の左上から順番に格納されている．PGMの場合，データ部の形式は，バイナリデータもしくはアスキーデータで格納されている．

バイナリデータ形式の場合は，1[byte]のデータが，対応するがその輝度値そのものを示すため，1[byte]が8[bit]であるコンピュータを用いる際の設定可能な最大輝度は255である．

一方，アスキーデータ形式の場合は，各画素の輝度値をアスキー文字に変換したものが格納される．各輝度値はスペース文字（0x20）で区切られ，最大輝度が255の場合は1画素分の輝度値は3桁に揃えられる．もし輝度値が2桁以下だった場合は先頭にスペース文字が加えられれ，3桁にして扱う．

例として，左上から輝度値が「3,255,167」であった場合を考えると，バイナリデータ形式の場合は「03 FF A7」となり，アスキーデータ形式の場合は「20 20 33 20 32 35 35 20 31 36 67 20」となる．

データがどちらで格納されているのかは，ヘッダ部分のマジックナンバで識別する．バイナリデータ形式の場合は「50 35」，アスキーデータ形式の場合は「50 32」である．
* 実験方法
[[原理]]章でまとめた知識を用いて，以下の課題を行い，結果について考察する．

1. Hadamard行列を求め，シーケンシの順番に並べ替える．
2. 2次元Hadamard変換及び逆変換を行う．
   
   　計算には除算が含まれるため，有効桁数を確保するために浮動小数点型の変数を用いて計算をする．ただし，最終的な輝度値は整数型であるため，最後に0.5を加えて整数型にキャスト（四捨五入を実現）する．
   
   　変換係数$\bm{G}$（または$g_{ji}$）をすべて用いた逆変換では，理論的には完全にもとに戻る．それを確認するために，原画像と逆変換画像をdiffコマンドを用いて比較せよ．計算誤差がある場合には，対応する画素同士の輝度値の差を求めて考察せよ．
3. 変換係数$\bm{G}$（または$g_{ji}$）のうち，下位（$j,i$ が若い方）のものだけを用いて逆変換をする．
4. 変換係数$\bm{G}$（または$g_{ji}$）のうち，上位のものだけを用いて逆変換をする．

* 実験結果及び考察
本実験に用いたHadamard行列$\bm{H}_N$ は，再帰法を用いて算出した．また，画像処理を行うにあたって用いた原画像$\bm{F}$ を図[[fig:original]]に示す．

#+CAPTION: 本実験に用いた原画像$\bm{F}$
#+NAME: fig:original
#+ATTR_LaTeX: :width 7cm
[[./img/original.eps]]

** 2次元Hadamard変換及び逆変換
図[[fig:original]]を2次元hadamard変換及び逆変換した結果を図[[fig:rev]]に示す．なお，この変換は行列演算を用いて行った．

#+CAPTION: 2次元Hadamard変換・逆変換後の画像
#+NAME: fig:rev
#+ATTR_LaTeX: :width 7cm
[[./img/rev.eps]]

出力されたファイルに対し，原画像との比較のためにdiffコマンドを用いたところ，「ファイル情報は同一である」という結果が得られた．よって理論通り変換行列$\bm{G}$ の全範囲を用いた逆変換では，入力と等しい結果が得られるということがわかった．

コンピュータで計算しているため，実際には除算の過程でいくらかの計算誤差が生まれているはずであるが，四捨五入で打ち消すことが出来ている．このことから，本手法は，出力画素値の誤差を$\pm 0.5$ 以下に抑えることができる優れた手法であると考えられる．

** 変換係数$\bm{G}$ のうち，下位のものだけを用いた逆変換
$N$ 次の変換係数$\bm{G}$ の$i$ 行$j$ 列の要素$\bm{G}(j,i)$ について，式([[eq:q14]])で表される条件で変換行列$\bm{G}$ を再定義する．

#+NAME: eq:q14
\begin{equation}
\bm{G}(j,i) = 
         \left\{ \begin{array}{ll}
             \bm{G}(j,i) & (i+j \leq N) \\
             0 & (otherwise)
         \end{array} \right.
\end{equation}

再定義された$\bm{G}$ を用いて逆変換を行った結果を図[[fig:upper]]に示す．

#+CAPTION: $\bm{G}$ の下位のみを用いた逆変換結果
#+NAME: fig:upper
#+ATTR_LaTeX: :width 7cm
[[./img/upper.eps]]

一見して変化がないように見えるため，拡大して比較したものを図[[fig:upper2]]に示す．
これを見ると，確実に画像が荒くなっているのがわかる．特に目立つのは，輝度値が異なる画素同士の境界であることもわかる．

#+CAPTION: 図[[fig:upper]]の拡大結果
#+NAME: fig:upper2
\begin{figure}[htbp]
 \begin{minipage}[t]{0.5\hsize}
  \begin{center}
   \includegraphics[width=70mm]{./img/up2.png}
  \end{center}
\captionsetup{labelformat=empty,labelsep=none}
  \caption{(a) 原画像}
  \addtocounter{figure}{-1}
 \end{minipage}
 \begin{minipage}[t]{0.5\hsize}
  \begin{center}
   \includegraphics[width=70mm]{./img/up1.png}
  \end{center}
\captionsetup{labelformat=empty,labelsep=none}
  \caption{(b) 逆変換後の画像}
  \addtocounter{figure}{-1}
 \end{minipage}
\end{figure}

$\bm{G}$ の下位のみを用いるということは，変換前にHadamard行列をシーケンシの順に並べ替えたことで，変換係数$\bm{G}$ の低周波成分のみを用いて逆変換したと考えられる．

\newpage

** 変換係数$\bm{G}$ のうち，上位のものだけを用いた逆変換
$N$ 次の変換係数$\bm{G}$ の$i$ 行$j$ 列の要素$\bm{G}(j,i)$ について，式([[eq:q15]])で表される条件で変換行列$\bm{G}$ を再定義する．

#+NAME: eq:q15
\begin{equation}
\bm{G}(j,i) = 
         \left\{ \begin{array}{ll}
             0 & (i+j < N) \\
             \bm{G}(j,i) & (otherwise)
         \end{array} \right.
\end{equation}

再定義された$\bm{G}$ を用いて逆変換を行った結果を図[[fig:lower]]に示す．

#+CAPTION: $\bm{G}$ の上位のみを用いた逆変換結果
#+NAME: fig:lower
#+ATTR_LaTeX: :width 7cm
[[./img/lower.eps]]

全体的に黒くなり，画像の特徴判別が困難であると判断したため，色相反転及び拡大をしたものを図[[fig:lower2]]に示す．この画像から，変換行列$\bm{G}$ の上位のみ，すなわち高周波成分のみを用いて逆変換を行うと，変換係数$\bm{G}$ のうち，下位のものだけを用いた逆変換の際に失われてしまった，輝度値の異なる画素同士の境界のみを抽出することが可能であると考えられる．

#+CAPTION: 図[[fig:lower]]の色相反転・拡大結果
#+NAME: fig:lower2
\begin{figure}[htbp]
 \begin{minipage}[t]{0.5\hsize}
  \begin{center}
   \fbox{\includegraphics[width=70mm]{./img/low1.eps}}
  \end{center}
\captionsetup{labelformat=empty,labelsep=none}
  \caption{(a) 色相反転画像}
  \addtocounter{figure}{-1}
 \end{minipage}
 \begin{minipage}[t]{0.5\hsize}
  \begin{center}
   \fbox{\includegraphics[width=70mm]{./img/low2.png}}
  \end{center}
\captionsetup{labelformat=empty,labelsep=none}
  \caption{(b) (a)を拡大した画像}
  \addtocounter{figure}{-1}
 \end{minipage}
\end{figure}

\newpage

* 検討課題
** 課題1
*** 問
2次元Hadamard変換を用いて画像情報圧縮を実現する方法を考察せよ．

*** 解答
画像が持つ情報量を圧縮するためには，画像全体における画素数を減らす必要があるが，その一方で，人が目で見たときに「画質が荒くなった」と感じてはならない．それを実現するために用いるべきは，変換係数$\bm{G}$ の低周波成分を用いて逆変換を行うことが有用であると考えられる．今回行列に含まれていた成分のうち，約半分しか用いずに変換を行ったが，その差異は画像を拡大しなければ確認できないほどであった．その一方で確実に情報量を減らすことができているため，圧縮できているといえる．

注意が必要なこととしては，pgm形式のファイルは，どれだけ情報量を減らしても，近傍画素との平均化等で画素数を減らさなければ，ファイルサイズは変化しないと考えられる．

** 課題2
*** 問
学籍番号の中で用いられている4つの数値（入学年，番号）を用いて$2 \times 2$ の画像$\bm{F}$ を構成するものとする．この$\bm{F}$ について，式([[eq:q12]]) 
により$g_{wv}$ を4つ求めよ（すなわち，$N=2$ として，$g_{00} , g_{10} , g_{01} , g_{11}$ ）．値は分数で表すこと．また，式([[eq:q13]]) により$\bm{F}$ を求めよ（途中計算も示すこと）．そのうえで，$g_{wv}$ が何を意味するのか考察せよ．

*** 解答
原画像$\bm{F}$ は式([[eq:q16]])である．また，算出した$g_{wv}$ を式([[eq:q17]])〜([[eq:q20]])に示す．

#+NAME: eq:q16
\begin{equation}
\bm{F} =  \left[
                      \begin{array}{rr}
                         1 & 8 \\
                         0 & 3 
                      \end{array}
                  \right]
\end{equation}

#+NAME: eq:q17
\begin{equation}
g_{00} = \frac{1}{4}
         \left[
            \begin{array}{rr}
                 1 & 1 \\
                 1 & 1 
            \end{array}
         \right]
         \left[
            \begin{array}{rr}
                 1 & 8 \\
                 0 & 3 
            \end{array}
         \right]
       = \frac{12}{4}
\end{equation}

#+NAME: eq:q18
\begin{equation}
g_{10} = \frac{1}{4}
         \left[
            \begin{array}{rr}
                 1 & -1 \\
                 1 & -1 
            \end{array}
         \right]
         \left[
            \begin{array}{rr}
                 1 & 8 \\
                 0 & 3 
            \end{array}
         \right]
       = - \frac{10}{4}
\end{equation}

#+NAME: eq:q19
\begin{equation}
g_{01} = \frac{1}{4}
         \left[
            \begin{array}{rr}
                 1 & 1 \\
                 -1 & -1 
            \end{array}
         \right]
         \left[
            \begin{array}{rr}
                 1 & 8 \\
                 0 & 3 
            \end{array}
         \right]
       = \frac{6}{4}
\end{equation}

#+NAME: eq:q20
\begin{equation}
g_{11} = \frac{1}{4}
         \left[
            \begin{array}{rr}
                 1 & -1 \\
                 -1 & 1 
            \end{array}
         \right]
         \left[
            \begin{array}{rr}
                 1 & 8 \\
                 0 & 3 
            \end{array}
         \right]
       = - \frac{4}{4}
\end{equation}

また，$\bm{F}$ を求める過程を式([[eq:q21]])に示す．

#+NAME: eq:q21
\begin{equation}
\begin{split}
\bm{F} &= 
         \frac{12}{4}
         \left[
            \begin{array}{rr}
                 1 & 1 \\
                 1 & 1 
            \end{array}
         \right] 
      -  \frac{10}{4}
         \left[
            \begin{array}{rr}
                 1 & -1 \\
                 1 & -1 
            \end{array}
         \right]
      +  \frac{6}{4}
         \left[
            \begin{array}{rr}
                 1 & 1 \\
                 -1 & -1 
            \end{array}
         \right] 
      -  \frac{4}{4}
         \left[
            \begin{array}{rr}
                 1 & -1 \\
                 -1 & 1 
            \end{array}
         \right] \\
      &= \left[
            \begin{array}{rr}
                 3 & 3 \\
                 3 & 3
            \end{array}
         \right]
      +  \left[
            \begin{array}{rr}
                 - \frac{5}{2} & \frac{5}{2} \\
                 - \frac{5}{2} & \frac{5}{2}
            \end{array}
         \right]
      +  \left[
            \begin{array}{rr}
                 \frac{3}{2} & \frac{3}{2} \\
                 - \frac{3}{2} & - \frac{3}{2}
            \end{array}
         \right]
      +  \left[
            \begin{array}{rr}
                 - 1 & 1 \\
                 1 & - 1
            \end{array}
         \right] \\
      &= \left[
            \begin{array}{rr}
                 2 & 4 \\
                 4 & 2
            \end{array}
         \right]
      +  \left[
            \begin{array}{rr}
                 - 1 & 4 \\
                 -4 & 1
            \end{array}
         \right] \\
      &= \left[
            \begin{array}{rr}
                 1 & 8 \\
                 0 & 3 
            \end{array}
         \right]
\end{split}
\end{equation}

ここで，$g_{wv}$ に含まれる分数のうち，分子により大きな値を持つもののみ（$g_{00},g_{01}$），分子により小さな値を持つもののみ（$g_{10},g_{11}$）のそれぞれで$\bm{F}$ を求めると，より大きな値をもつもののみを用いたほうが，原画像$\bm{F}$ に近い値となることは，計算過程からもわかる．よって，$g_{wv}$ は，画像を周波数空間へ変換した際に，どれだけ原画像の情報量を保持しているかを意味すると考えられる．
\newpage
* 付録
作成した関数群をListing1に，それらを呼び出すmain関数の抜粋をListing2に示す．

\begin{lstlisting}[caption=作成した関数群,label=list1]
/* Hadamard行列を求める関数 */
void CalcHadamard(int k, float H2k[2*k][2*k])
{
  int i,j;
  
  if(k == 1){
    for(i = 0; i < 2; i++){
      for(j = 0;j < 2 ; j++){
        H2k[i][j] = 1;
      }
      H2k[1][1] = -1;
    }
  }

  else{
    float Hk[k][k];
    CalcHadamard(k/2 , Hk);
    for(i = 0;i < 2*k; i++){
      for(j = 0;j < 2*k ; j++){
        if(i < k || j < k){
          H2k[i][j] = Hk[i%k][j%k];
        }else{
          H2k[i][j] = -1 * Hk[i%k][j%k];
        }
      }
    }
  }
}

/* シーケンシを算出する関数 */
void Sequency(int n,float HN[n][n])
{
  int i,j;
  float s[n];
  for(i = 0; i < n; i++){
    s[i] = 0;
    for(j = 0; j < n-1; j++){
      s[i] += 0.5*abs(HN[i][j] - HN[i][j+1]);
    }
  }
  Replace(n,HN,s);
}

/* 算出したシーケンシを元に行を入れ替える関数 */
void Replace(int n,float HN[n][n],float s[n])
{
  int i,j;
  float swap[n][n];
  for(i = 0; i < n; i++){
    for(j = 0; j < n; j++){
      swap[(int)s[i]][j] = HN[i][j];
    }
  }
  
  for(i = 0; i < n; i++){
    for(j = 0; j < n; j++){
      HN[i][j] = swap[i][j];
    }
  }
}

/* 2次元Hadamard変換を行う関数 */
void CalcMatrix(int n,int F[n][n],float G[n][n],float HN[n][n])
{
  int buffer[n][n];
  int i,j,k;
  for(i = 0; i < n; i++){
    for(j = 0; j < n; j++){
      buffer[i][j] = 0;
      for(k = 0; k < n; k++){
        buffer[i][j] += ((int)HN[i][k] * F[k][j]);
      }
    }
  }
  
  for(i = 0; i < n; i++){
    for(j = 0; j < n; j++){
      G[i][j] = 0;
      for(k = 0; k < n; k++){
        G[i][j] += buffer[i][k] * HN[j][k];
      }
      G[i][j] = (float)G[i][j]/(float)n;
    }
  }  
}

/* 変換行列の全要素を用いて逆変換する関数 */
void CalcMatrixInv(int n, float G[n][n],int Fd[n][n],float HN[n][n])
{
  float a[n][n];
  int i,j,k;
  for(i = 0; i < n; i++){
    for(j = 0; j < n; j++){
      a[i][j] = 0;
      for(k = 0; k < n; k++){
        a[i][j] += HN[i][k] * G[k][j];
      }
    }
  }

  float b[n][n];
  for(i = 0; i < n; i++){
    for(j = 0; j < n; j++){
      b[i][j] = 0;
      for(k = 0; k < n; k++){
        b[i][j] += a[i][k] * HN[j][k];
      }
      Fd[i][j] = (int)(((float)b[i][j]/(float)n)+0.5);
    }
  }  
}

/* 変換行列の下位要素のみを用いて逆変換する関数 */
void CalcMatrixInvUpper(int n, float G[n][n],int Fd[n][n],float HN[n][n])
{
  int i,j,k;
  for(i = 0; i < n; i++){
    for(j = 0; j < n; j++){
      if(i+j > n)
        G[i][j] = 0;
    }
  }

  float a[n][n];
  for(i = 0; i < n; i++){
    for(j = 0; j < n; j++){
      a[i][j] = 0;
      for(k = 0; k < n; k++){
        a[i][j] += HN[i][k] * G[k][j];
      }
    }
  }

  float b[n][n];
  for(i = 0; i < n; i++){
    for(j = 0; j < n; j++){
      b[i][j] = 0;
      for(k = 0; k < n; k++){
        b[i][j] += a[i][k] * HN[j][k];
      }
      Fd[i][j] = (int)(((float)b[i][j]/(float)n)+0.5);
    }
  }  
}

/* 変換行列の上位要素のみを用いて逆変換する関数 */
void CalcMatrixInvLower(int n, float G[n][n],int Fd[n][n],float HN[n][n])
{
  int i,j,k;
  for(i = 0; i < n; i++){
    for(j = 0; j < n; j++){
      if(i+j <= n)
        G[i][j] = 0;
    }
  }

  float a[n][n];
  for(i = 0; i < n; i++){
    for(j = 0; j < n; j++){
      a[i][j] = 0;
      for(k = 0; k < n; k++){
        a[i][j] += HN[i][k] * G[k][j];
      }
    }
  }

  float b[n][n];
  for(i = 0; i < n; i++){
    for(j = 0; j < n; j++){
      b[i][j] = 0;
      for(k = 0; k < n; k++){
        b[i][j] += a[i][k] * HN[j][k];
      }
      Fd[i][j] = (int)(((float)b[i][j]/(float)n)+0.5);
    }
  }  
}
\end{lstlisting}

\newpage

\begin{lstlisting}[caption=main関数（抜粋）,label=list2]
  /* processing */
  int n = X_SIZE;
  int k = n/2;
  float HN[X_SIZE][Y_SIZE];
  CalcHadamard(k,HN);
  Sequency(n,HN);
  int F[n][n];

  for(i = 0; i < n; i++){
    for(j = 0; j < n; j++){
      F[i][j] = in[i+j*n];
    }
  }

  float G[n][n];
  CalcMatrix(n,F,G,HN);
  int Fd[n][n];
  CalcMatrixInvLower(n,G,Fd,HN);
  
  for(i = 0; i < n; i++){
    for(j = 0; j < n; j++){
      if(Fd[i][j] > 255)
        Fd[i][j] = 255;
      if(Fd[i][j] < 0)
        Fd[i][j] = 0;
      out[i+j*n] = Fd[i][j];
    }
  }
\end{lstlisting}
